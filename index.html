<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM_GLOBE.EXE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            color: #00ff41;
            cursor: crosshair;
        }
        
        /* Scanlines effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 65, 0.03),
                rgba(0, 255, 65, 0.03) 1px,
                transparent 2px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 1000;
        }
        
        #globe-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
        }
        
        svg {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            filter: contrast(1) brightness(1.3);
        }
        
        svg:active {
            cursor: crosshair;
        }
        
        /* Océan avec gradients thermiques */
        .ocean {
            fill: url(#oceanThermalGradient);
            filter: url(#oceanFlow);
        }
        
        /* Terre base - visible mais discrète */
        .land {
            fill: #1a1a1a;
            stroke: #00ff41;
            stroke-width: 0.4;
            opacity: 0.7;
        }
        
        /* Biomes climatiques visibles avec effets améliorés */
        .rainforest { 
            fill: url(#rainforestClimate);
            opacity: 0.9;
            filter: url(#humidityEffect);
            mix-blend-mode: multiply;
        }
        .desert { 
            fill: url(#desertClimate);
            opacity: 0.9;
            filter: url(#heatEffect);
            mix-blend-mode: multiply;
        }
        .tundra { 
            fill: url(#tundraClimate);
            opacity: 0.9;
            filter: url(#coldEffect);
            mix-blend-mode: multiply;
        }
        .temperate { 
            fill: url(#temperateClimate);
            opacity: 0.9;
            mix-blend-mode: multiply;
        }
        .savanna { 
            fill: url(#savannaClimate);
            opacity: 0.9;
            filter: url(#drySeasonEffect);
            mix-blend-mode: multiply;
        }
        .taiga { 
            fill: url(#taigaClimate);
            opacity: 0.9;
            filter: url(#borealEffect);
            mix-blend-mode: multiply;
        }
        
        /* Grille système */
        .graticule {
            fill: none;
            stroke: rgba(0, 255, 65, 0.1);
            stroke-width: 0.3;
            stroke-dasharray: 2,2;
        }
        
        /* Points de données */
        .location-point {
            cursor: pointer;
        }
        
        .location-point circle {
            fill: #ff0040;
            stroke: #00ff41;
            stroke-width: 2;
            filter: url(#redGlow);
            animation: dataFlash 1.5s linear infinite;
        }
        
        @keyframes dataFlash {
            0%, 100% { 
                r: 3;
                opacity: 1;
                stroke-width: 2;
            }
            50% { 
                r: 5;
                opacity: 0.7;
                stroke-width: 4;
            }
        }
        
        .location-point:hover circle {
            animation: none;
            r: 6;
            stroke-width: 3;
            fill: #00ff41;
            stroke: #ff0040;
        }
        
        /* Overlay système mosaïque */
        #detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(10, 10, 10, 0.75);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow-y: auto;
        }
        
        #detail-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .detail-content {
            width: 100%;
            min-height: 200vh;
            padding: 80px 20px;
            position: relative;
        }
        
        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #000;
            border: 2px solid #ff0040;
            color: #ff0040;
            padding: 10px 20px;
            cursor: crosshair;
            transition: all 0.2s;
            font-size: 12px;
            letter-spacing: 2px;
            z-index: 1002;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
        }
        
        .close-btn:hover {
            background: #ff0040;
            color: #000;
            transform: none;
            box-shadow: 0 0 20px #ff0040;
        }
        
        /* Mosaïque brutaliste */
        .mosaic-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .mosaic-block {
            position: absolute;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid #00ff41;
            padding: 15px;
            transition: all 0.1s;
            box-shadow: 0 0 0 1px #ff0040 inset;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .mosaic-block:hover {
            transform: none;
            border-color: #ff0040;
            box-shadow: 0 0 0 2px #00ff41 inset, 0 0 20px rgba(255, 0, 64, 0.3);
            background: linear-gradient(135deg, #2a0a0a 0%, #1a0a0a 100%);
        }
        
        .mosaic-block h3 {
            color: #ff0040;
            font-size: 11px;
            margin-bottom: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
            border-bottom: 1px solid #ff0040;
            padding-bottom: 5px;
        }
        
        .mosaic-block img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            margin-bottom: 10px;
            filter: grayscale(70%) contrast(120%) brightness(80%);
            border: 1px solid #00ff41;
        }
        
        .mosaic-block p {
            line-height: 1.3;
            color: #00ff41;
            font-size: 9px;
            letter-spacing: 0.5px;
        }
        
        /* Tailles système mosaïque */
        .mosaic-block.tiny { width: 160px; height: 200px; }
        .mosaic-block.small { width: 200px; height: 250px; }
        .mosaic-block.medium { width: 250px; height: 300px; }
        .mosaic-block.large { width: 300px; height: 350px; }
        
        /* Aperçu terminal */
        #hover-preview {
            position: fixed;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.1s ease;
        }
        
        #hover-preview.visible {
            opacity: 1;
        }
        
        .hover-title {
            position: absolute;
            background: #000;
            color: #00ff41;
            padding: 8px 15px;
            border: 1px solid #00ff41;
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: 0 0 0 1px #ff0040 inset;
        }
        
        .hover-image {
            position: absolute;
            border: 2px solid #ff0040;
            width: 180px;
            height: 120px;
            object-fit: cover;
            filter: grayscale(60%) contrast(130%);
            box-shadow: 0 0 0 1px #00ff41 inset;
        }
        
        /* Effet machine à écrire en bas à droite */
        .typewriter-container {
            position: fixed;
            bottom: 20px;
            right: 300px;
            width: 900px;
            height: 60px;
            background: rgba(0, 0, 0, 0);
            border: 0px solid #00ff41;
            color: #00ff41;
            padding: 15px;
            font-size: 12px;
            letter-spacing: 1px;
            z-index: 15;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            align-items: center;
            box-shadow: 0 0 0 0px #ff0040 inset, 0 0 5px rgba(0, 255, 65, 0.2);
        }
        
        .typewriter-text {
            color: #00ff41;
            font-weight: 200;
            line-height: 1.4;
            white-space: nowrap;
            overflow: hidden;
            min-height: 1.1em;
        }
        
        .cursor {
            display: inline-block;
            background-color: #00ff41;
            width: 8px;
            height: 14px;
            animation: blink s infinite;
            margin-left: 2px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Menu de navigation */
        .nav-menu {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 10;
        }
        
        .nav-menu a {
            display: block;
            color: #00ff41;
            font-size: 14px;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-decoration: none;
            font-weight: 400;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            padding: 5px 0;
            border-left: 2px solid transparent;
            padding-left: 10px;
            transition: all 0.2s ease;
        }
        
        .nav-menu a:hover {
            color: #ff0040;
            border-left-color: #ff0040;
            padding-left: 15px;
            text-shadow: 0 0 10px #ff0040;
        }

        /* AJOUT: Panneau d'informations contextuelles - Style Raw */
        .biome-info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 180px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px;
            font-size: 9px;
            letter-spacing: 0.5px;
            z-index: 25;
            font-family: 'JetBrains Mono', monospace;
            line-height: 1.3;
            transition: opacity 0.2s ease;
        }

        .biome-info-panel.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        h1 {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff0040;
            font-size: 16px;
            letter-spacing: 3px;
            margin: 0;
            z-index: 10;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            border: 1px solid #ff0040;
            padding: 10px 15px;
            background: #000;
            box-shadow: 0 0 0 1px #00ff41 inset;
        }
        
        /* Terminal flicker */
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.98; }
        }
        
        body {
            animation: flicker 0.15s infinite linear alternate;
        }
        
        /* Responsive brutal */
        @media (max-width: 768px) {
            .mosaic-block.tiny { width: 140px; height: 180px; }
            .mosaic-block.small { width: 170px; height: 220px; }
            .mosaic-block.medium { width: 200px; height: 260px; }
            .mosaic-block.large { width: 230px; height: 300px; }
            
            h1 {
                font-size: 12px;
                padding: 8px 12px;
            }
            
            .nav-menu {
                top: 70px;
            }
            
            .nav-menu a {
                font-size: 12px;
                margin-bottom: 8px;
            }
            
            .typewriter-container {
                width: 300px;
                height: 50px;
                padding: 10px;
                font-size: 10px;
            }

            .biome-info-panel {
                width: 150px;
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <h1>NOT.LOST.FUTURZ</h1>
    
    <!-- Menu de navigation -->
    <nav class="nav-menu">
        <a href="#bio">Bio</a>
        <a href="#portfolio">Portfolio</a>
        <a href="#contact">Contact</a>
        <a href="#manifeste">Manifeste</a>
    </nav>
    
    <!-- Effet machine à écrire en bas à droite -->
    <div class="typewriter-container">
        <div class="typewriter-text" id="typewriter-display"></div>
        <span class="cursor"></span>
    </div>

    <!-- AJOUT: Panneau d'informations contextuelles -->
    <div class="biome-info-panel hidden" id="biome-info-panel">
        <div id="biome-data-display"></div>
    </div>
    
    <!-- Aperçu terminal -->
    <div id="hover-preview">
        <div class="hover-title"></div>
        <img class="hover-image" src="" alt="">
    </div>
    
    <div id="globe-container">
        <svg id="globe">
            <defs>
                <!-- Gradient océan thermique inspiré nullschool -->
                <radialGradient id="oceanThermalGradient">
                    <stop offset="0%" style="stop-color:#C9d;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#a9B;stop-opacity:0.8" />
                    <stop offset="60%" style="stop-color:#a9d;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#004080;stop-opacity:0.6" />
                </radialGradient>
                
                <!-- Gradients climatiques pour biomes -->
                <linearGradient id="rainforestClimate" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#006600;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#009900;stop-opacity:1" />
                    <stop offset="60%" style="stop-color:#00cc00;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#00ff00;stop-opacity:1" />
                </linearGradient>
                
                <linearGradient id="desertClimate" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#cc6600;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#ff8800;stop-opacity:1" />
                    <stop offset="60%" style="stop-color:#ffaa00;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ffcc00;stop-opacity:1" />
                </linearGradient>
                
                <linearGradient id="tundraClimate" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#6666cc;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#8888dd;stop-opacity:1" />
                    <stop offset="60%" style="stop-color:#aaaaee;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ccccff;stop-opacity:1" />
                </linearGradient>
                
                <linearGradient id="temperateClimate" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#336633;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#66aa66;stop-opacity:1" />
                    <stop offset="60%" style="stop-color:#88cc88;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#aaffaa;stop-opacity:1" />
                </linearGradient>
                
                <linearGradient id="savannaClimate" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#cc9900;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#ddaa33;stop-opacity:1" />
                    <stop offset="60%" style="stop-color:#eebb66;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ffcc99;stop-opacity:1" />
                </linearGradient>
                
                <linearGradient id="taigaClimate" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#004d4d;stop-opacity:1" />
                    <stop offset="30%" style="stop-color:#006666;stop-opacity:1" />
                    <stop offset="60%" style="stop-color:#008080;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#00cccc;stop-opacity:1" />
                </linearGradient>
                
               
                

    <!-- Overlay système mosaïque -->
    <div id="detail-overlay">
        <button class="close-btn" onclick="closeDetailOverlay()">[X] TERMINATE</button>
        <div class="detail-content">
            <!-- Contenu généré dynamiquement -->
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    
    <script>
        // Configuration système
        const width = window.innerWidth;
        const height = window.innerHeight;
        const scale = Math.min(width, height) / 2.3;
        const sensitivity = 0.75;
        
        // Slogans système pour effet machine à écrire
        const slogans = [
            "are you a pervert secretly horny for the apocalypse ?",
            "Devenu si etranger à lui même que sa propre destruction lui apparait comme un spectacle de premier ordre",
            "NI CAPITALISME VERT NI EFFONDREMENT ",
            "L'URGENCE CLIMATIQUE EST UNE GUERRE DE CLASSE",
            "DÉCROISSANCE DES RICHES - PROSPÉRITÉ POUR TOUS",
            "Non pas seulement moteur de l'histoire, mais moteur de la vie elle même",
            "ABOLIR LA PROPRIÉTÉ PRIVÉE DES MOYENS DE DESTRUCTION",
            ,
        ];
        
        let currentSloganIndex = 0;
        let isTyping = false;
        
        // Effet machine à écrire réaliste avec corrections
        function typewriterEffect() {
            if (isTyping) return;
            
            const display = document.getElementById('typewriter-display');
            const currentSlogan = slogans[currentSloganIndex];
            let currentText = '';
            let charIndex = 0;
            
            isTyping = true;
            display.textContent = '';
            
            function typeChar() {
                if (charIndex < currentSlogan.length) {
                    // Vitesse de frappe variable (réaliste)
                    const typingSpeed = Math.random() * 0.1 + 1; // 50-150ms
                    
                    // Parfois faire une erreur et corriger
                    if (Math.random() < 0.00 && charIndex > 3) { // 0% de chance d'erreur
                        const wrongChar = String.fromCharCode(Math.floor(Math.random() * 26) + 97);
                        currentText += wrongChar;
                        display.textContent = currentText;
                        
                        // Pause de réflexion
                        setTimeout(() => {
                            // Effacer le mauvais caractère
                            currentText = currentText.slice(0, -1);
                            display.textContent = currentText;
                            
                            // Pause avant de taper le bon caractère
                            setTimeout(() => {
                                currentText += currentSlogan[charIndex];
                                display.textContent = currentText;
                                charIndex++;
                                setTimeout(typeChar, typingSpeed);
                            }, 0.1);
                        }, 0.01);
                    } else {
                        // Parfois une pause de réflexion
                        const pauseChance = Math.random();
                        let pauseTime = 0;
                        
                        if (pauseChance < 0.03) { // 3% - longue pause
                            pauseTime = Math.random() * 8 + 5;
                        } else if (pauseChance < 0.1) { // 7% - courte pause
                            pauseTime = Math.random() * 300 + 200;
                        }
                        
                        setTimeout(() => {
                            currentText += currentSlogan[charIndex];
                            display.textContent = currentText;
                            charIndex++;
                            setTimeout(typeChar, typingSpeed);
                        }, pauseTime);
                    }
                } else {
                    // Fin du message - pause avant le suivant
                    setTimeout(() => {
                        // Effacement progressif
                        function eraseText() {
                            if (currentText.length > 0) {
                                currentText = currentText.slice(0, -5);
                                display.textContent = currentText;
                                setTimeout(eraseText, 0.3);
                            } else {
                                // Passer au slogan suivant
                                currentSloganIndex = (currentSloganIndex + 1) % slogans.length;
                                isTyping = false;
                                setTimeout(typewriterEffect, 50);
                            }
                        }
                        
                        setTimeout(eraseText, 3000); // Attendre 3s avant d'effacer
                    }, 100);
                }
            }
            
            // Démarrer avec une petite pause
            setTimeout(typeChar, 300);
        }
        
        // Initialiser l'effet machine à écrire
        setTimeout(typewriterEffect, 100);

        // AJOUT: Système d'informations contextuelles simplifié
        const biomeDataInfo = {
            ocean: { temp: [-2, 30], hum: [95, 100], pol: [5, 45], pop: [0, 0], bio: [15000, 250000], prec: [0, 0] },
            rainforest: { temp: [20, 35], hum: [77, 88], pol: [15, 85], pop: [1, 25], bio: [40000, 100000], prec: [1500, 4000] },
            desert: { temp: [10, 50], hum: [10, 30], pol: [2, 25], pop: [0, 5], bio: [500, 3000], prec: [0, 250] },
            tundra: { temp: [-40, 18], hum: [60, 80], pol: [1, 15], pop: [0, 0.1], bio: [200, 1500], prec: [150, 400] },
            temperate: { temp: [-5, 30], hum: [50, 75], pol: [25, 120], pop: [10, 200], bio: [3000, 15000], prec: [500, 1500] },
            savanna: { temp: [15, 35], hum: [35, 70], pol: [8, 55], pop: [2, 35], bio: [8000, 25000], prec: [300, 1200] },
            taiga: { temp: [-50, 20], hum: [55, 75], pol: [3, 35], pop: [0, 2], bio: [2000, 8000], prec: [400, 850] }
        };

        function randRange(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function formatBigNumber(num) {
            if (num >= 1000000) return Math.floor(num / 1000000) + 'M';
            if (num >= 1000) return Math.floor(num / 1000) + 'K';
            return Math.floor(num);
        }

        function updateBiomeInfoPanel(biomeType, lat, lon) {
            const data = biomeDataInfo[biomeType] || biomeDataInfo.ocean;
            const panel = document.getElementById('biome-info-panel');
            const display = document.getElementById('biome-data-display');
            
            const temp = randRange(data.temp[0], data.temp[1]);
            const hum = randRange(data.hum[0], data.hum[1]);
            const pol = randRange(data.pol[0], data.pol[1]);
            const pop = randRange(data.pop[0] * 10, data.pop[1] * 10) / 10;
            const bio = randRange(data.bio[0], data.bio[1]);
            const prec = randRange(data.prec[0], data.prec[1]);
            
            display.innerHTML = `
                TEMP: ${temp}°C<br>
                HUM: ${hum}%<br>
                POL: ${pol}ppm<br>
                POP: ${formatBigNumber(pop)}/km²<br>
                BIO: ${formatBigNumber(bio)}sp<br>
                PREC: ${prec}mm<br>
                <br>
                ${lat.toFixed(1)}°N ${lon.toFixed(1)}°E
            `;
            
            panel.classList.remove('hidden');
        }

        function detectBiomeFromCursor(point) {
            const coords = projection.invert(point);
            if (!coords) return null;
            
            const [lon, lat] = coords;
            
            if (Math.abs(lat) > 66.5) return { biome: 'tundra', lat, lon };
            if (Math.abs(lat) > 50) return { biome: 'taiga', lat, lon };
            
            if (lat > -10 && lat < 10) {
                if ((lon > -80 && lon < -35) || (lon > 10 && lon < 30) || (lon > 95 && lon < 140)) {
                    return { biome: 'rainforest', lat, lon };
                }
            }
            
            if ((lat > 15 && lat < 35 && lon > -20 && lon < 65) || 
                (lat > -35 && lat < -15 && lon > 115 && lon < 145)) {
                return { biome: 'desert', lat, lon };
            }
            
            if (lat > -25 && lat < 15 && lon > 15 && lon < 50) {
                return { biome: 'savanna', lat, lon };
            }
            
            const distanceToLand = Math.min(Math.abs(lat - 60), Math.abs(lon % 40));
            if (distanceToLand > 10) return { biome: 'ocean', lat, lon };
            
            return { biome: 'temperate', lat, lon };
        }
        // FIN AJOUT
        
        // Données système
        const locations = [
            {
                id: 'amazon',
                name: 'RAINFOREST_DATA.001',
                coords: [-60.0, -3.0],
                preview: {
                    image: 'https://images.unsplash.com/photo-1516026672322-bc52d61a55d5?w=400',
                    text: 'FOREST MATRIX - BIODIVERSITY_MAX'
                },
                detail: {
                    title: 'AMAZON_SYSTEM.LOG',
                    sections: [
                        {
                            subtitle: 'SPECIES_COUNT',
                            text: 'DATABASE: 40,000 PLANT_SPECIES | 1,300 BIRD_TYPES | 3,000 FISH_VARIANTS. SYSTEM_STATUS: CRITICAL_IMPORTANCE.',
                            image: 'https://images.unsplash.com/photo-1584593604164-c0c3c3c20d6e?w=600'
                        },
                        {
                            subtitle: 'OXYGEN_OUTPUT',
                            text: 'PROCESSING: 20% GLOBAL_O2_PRODUCTION. WATER_DISCHARGE: 209,000M³/SEC. STATUS: ACTIVE_MONITORING.',
                            image: 'https://images.unsplash.com/photo-1577897113292-3b95936e5206?w=600'
                        }
                    ]
                }
            },
            {
                id: 'sahara',
                name: 'DESERT_PROTOCOL.002',
                coords: [10.0, 23.0],
                preview: {
                    image: 'https://images.unsplash.com/photo-1509316785289-025f5b846b35?w=400',
                    text: 'SAND_MATRIX - 9M_KM²'
                },
                detail: {
                    title: 'SAHARA_SYSTEM.LOG',
                    sections: [
                        {
                            subtitle: 'EXTREME_CONDITIONS',
                            text: 'TEMP_RANGE: 50°C_DAY | 0°C_NIGHT. PRECIPITATION: <25MM/YEAR. SURVIVAL_MODE: ACTIVATED.',
                            image: 'https://images.unsplash.com/photo-1539437829697-1b4ed5aebd19?w=600'
                        },
                        {
                            subtitle: 'ADAPTED_LIFEFORMS',
                            text: 'SPECIES_COUNT: 3000+ ADAPTED_UNITS. FENNEC.EXE | ADDAX.SYS | ROSE_OF_JERICHO.DLL ACTIVE.',
                            image: 'https://images.unsplash.com/photo-1547234935-80c66375b153?w=600'
                        }
                    ]
                }
            },
            {
                id: 'siberia',
                name: 'TAIGA_NETWORK.003',
                coords: [100.0, 60.0],
                preview: {
                    image: 'https://images.unsplash.com/photo-1548777123-e216912df7d8?w=400',
                    text: 'BOREAL_FOREST - 17M_KM²'
                },
                detail: {
                    title: 'TAIGA_SYSTEM.LOG',
                    sections: [
                        {
                            subtitle: 'NORDIC_ECOSYSTEM',
                            text: 'CONIFER_DOMINANT: SPRUCE.EXE | FIR.SYS | LARCH.DLL. TEMP_RANGE: -50°C TO +20°C.',
                            image: 'https://images.unsplash.com/photo-1519904981063-b0cf448d479e?w=600'
                        },
                        {
                            subtitle: 'FAUNA_DATABASE',
                            text: 'ACTIVE_SPECIES: BEAR.SYS | LYNX.EXE | MOOSE.DLL | WOLF.NET. MIGRATION_PATTERNS: MONITORED.',
                            image: 'https://images.unsplash.com/photo-1474511320061-e2f375371a78?w=600'
                        }
                    ]
                }
            },
            {
                id: 'serengeti',
                name: 'SAVANNA_CLUSTER.004',
                coords: [34.8, -2.3],
                preview: {
                    image: 'https://images.unsplash.com/photo-1516426122078-c23e76319801?w=400',
                    text: 'MIGRATION_PROTOCOL'
                },
                detail: {
                    title: 'SERENGETI_SYSTEM.LOG',
                    sections: [
                        {
                            subtitle: 'MIGRATION_DATA',
                            text: 'WILDEBEEST: 1.5M_UNITS | ZEBRA: 200K_UNITS. DISTANCE: 3000KM_ANNUAL. STATUS: TRACKING.',
                            image: 'https://images.unsplash.com/photo-1535083252457-6080fe29be45?w=600'
                        },
                        {
                            subtitle: 'PREDATOR_ARRAY',
                            text: 'LION: 3000_UNITS | LEOPARD: 1000_UNITS | CHEETAH: 500_UNITS. BALANCE: MAINTAINED.',
                            image: 'https://images.unsplash.com/photo-1547970810-dc1eac37d174?w=600'
                        }
                    ]
                }
            },
            {
                id: 'coral',
                name: 'CORAL_MAINFRAME.005',
                coords: [145.7, -16.0],
                preview: {
                    image: 'https://images.unsplash.com/photo-1583212292454-1fe6229603b7?w=400',
                    text: 'REEF_SYSTEM - 2300KM'
                },
                detail: {
                    title: 'CORAL_SYSTEM.LOG',
                    sections: [
                        {
                            subtitle: 'MARINE_DATABASE',
                            text: 'CORAL_TYPES: 600 | FISH_SPECIES: 1625 | SHARK_VARIANTS: 133. ECOSYSTEM: COMPLEX.',
                            image: 'https://images.unsplash.com/photo-1559827260-dc66d52bef19?w=600'
                        },
                        {
                            subtitle: 'SYSTEM_WARNING',
                            text: 'TEMPERATURE_THREAT: ACTIVE. BLEACHING: 50%_SINCE_1995. STATUS: CRITICAL_MONITORING.',
                            image: 'https://images.unsplash.com/photo-1583212292454-1fe6229603b7?w=600'
                        }
                    ]
                }
            },
            {
                id: 'antarctica',
                name: 'ICE_TERMINAL.006',
                coords: [0, -80],
                preview: {
                    image: 'https://images.unsplash.com/photo-1560711963-1106c142e616?w=400',
                    text: 'FROZEN_CONTINENT - 14M_KM²'
                },
                detail: {
                    title: 'ANTARCTICA_SYSTEM.LOG',
                    sections: [
                        {
                            subtitle: 'POLAR_CONDITIONS',
                            text: 'TEMP_RECORD: -89.2°C. FRESHWATER_STORAGE: 90%_GLOBAL_RESERVES. STATUS: MONITORED.',
                            image: 'https://images.unsplash.com/photo-1548699545-24430002a09b?w=600'
                        },
                        {
                            subtitle: 'EXTREME_LIFE',
                            text: 'EMPEROR_PENGUIN.EXE | WEDDELL_SEAL.SYS | ANTARCTIC_KRILL.DLL. FOOD_CHAIN: BASE_LEVEL.',
                            image: 'https://images.unsplash.com/photo-1551415923-a2297c7fda79?w=600'
                        }
                    ]
                }
            }
        ];
        
        // Initialisation système SVG
        const svg = d3.select('#globe');
        const g = svg.append('g');
        
        const projection = d3.geoOrthographic()
            .scale(scale)
            .translate([width / 2, height / 2])
            .clipAngle(90);
            
        const path = d3.geoPath().projection(projection);
        const graticule = d3.geoGraticule();
        
        // Groupes système
        const oceanGroup = g.append('g');
        const graticuleGroup = g.append('g');
        const landGroup = g.append('g');
        const biomesGroup = g.append('g');
        const pointsGroup = g.append('g');
        
        // Variables système
        let autoRotate = true;
        let countriesData = null;
        let currentZoom = 1;
        
        // Configuration zoom
        const zoom = d3.zoom()
            .scaleExtent([0.5, 8])
            .on('zoom', handleZoom);
        
        function handleZoom(event) {
            currentZoom = event.transform.k;
            const newScale = scale * currentZoom;
            projection.scale(newScale);
            updateAll();
        }
        
        // Chargement données géographiques
        Promise.all([
            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json'),
            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json')
        ]).then(([world, land]) => {
            // Océan système avec effets thermiques
            oceanGroup.append('path')
                .datum({type: 'Sphere'})
                .attr('class', 'ocean')
                .attr('d', path)
               
            
            // Grille système discrète
            graticuleGroup.append('path')
                .datum(graticule)
                .attr('class', 'graticule')
                .attr('d', path);
            
            // Continents base - structure principale
            const landFeatures = topojson.feature(land, land.objects.land);
            landGroup.selectAll('path')
                .data(landFeatures.features)
                .enter().append('path')
                .attr('class', 'land')
                .attr('d', path);
            
            // Pays pour biomes climatiques (sans frontières visibles)
            countriesData = topojson.feature(world, world.objects.countries);
            
            // Application biomes climatiques avancés
            biomesGroup.selectAll('path')
                .data(countriesData.features)
                .enter().append('path')
                .attr('class', d => getBiomeClass(d))
                .attr('d', path)
                .style('stroke', 'none');  // Suppression frontières nationales
            
            // Points données système
            createLocationPoints();
            
            // Démarrage animation climatique
            startAnimation();
            updateAll();
        });
        
        // Classification climatique avancée inspirée earth.nullschool
        function getBiomeClass(feature) {
            const bounds = d3.geoBounds(feature);
            const centerLat = (bounds[0][1] + bounds[1][1]) / 2;
            const centerLon = (bounds[0][0] + bounds[1][0]) / 2;
            
            // Zones polaires (Arctique/Antarctique)
            if (Math.abs(centerLat) > 66.5) return 'tundra'; // Cercles polaires
            
            // Zones subarctiques - Taïga
            if (Math.abs(centerLat) > 50 && Math.abs(centerLat) <= 66.5) {
                if (centerLon > -170 && centerLon < 170) return 'taiga'; // Ceinture boréale
            }
            
            // Zones tropicales humides - Forêts équatoriales
            if (centerLat > -10 && centerLat < 10) {
                // Bassin amazonien
                if (centerLon > -80 && centerLon < -35) return 'rainforest';
                // Bassin du Congo
                if (centerLon > 10 && centerLon < 30 && centerLat > -5 && centerLat < 5) return 'rainforest';
                // Indonésie/Malaisie
                if (centerLon > 95 && centerLon < 140 && centerLat > -10 && centerLat < 10) return 'rainforest';
            }
            
            // Zones arides - Déserts
            // Sahara et péninsule arabique
            if (centerLat > 15 && centerLat < 35) {
                if (centerLon > -20 && centerLon < 65) return 'desert';
            }
            // Déserts d'Asie centrale
            if (centerLat > 35 && centerLat < 50 && centerLon > 45 && centerLon < 90) return 'desert';
            // Australie centrale
            if (centerLat > -35 && centerLat < -15 && centerLon > 115 && centerLon < 145) return 'desert';
            // Déserts américains
            if (centerLat > 25 && centerLat < 40 && centerLon > -125 && centerLon < -100) return 'desert';
            // Atacama et Patagonie
            if (centerLat > -30 && centerLat < -15 && centerLon > -75 && centerLon < -65) return 'desert';
            
            // Savanes tropicales
            // Afrique de l'Est et du Sud
            if (centerLat > -25 && centerLat < 15 && centerLon > 15 && centerLon < 50) {
                if (!(centerLon > 10 && centerLon < 30 && centerLat > -5 && centerLat < 5)) { // Exclut forêt Congo
                    return 'savanna';
                }
            }
            // Cerrado brésilien
            if (centerLat > -20 && centerLat < -5 && centerLon > -60 && centerLon < -40) return 'savanna';
            // Nord Australie
            if (centerLat > -20 && centerLat < -10 && centerLon > 120 && centerLon < 145) return 'savanna';
            
            // Zones tempérées par défaut
            return 'temperate';
        }
        
        // Création points données
        function createLocationPoints() {
            const groups = pointsGroup.selectAll('.location-point')
                .data(locations)
                .enter().append('g')
                .attr('class', 'location-point')
                .on('mouseenter', showPreview)
                .on('mouseleave', hidePreview)
                .on('click', showDetail);
                
            groups.append('circle')
                .attr('r', 3);
        }
        
        // Mise à jour système
        function updateAll() {
            g.selectAll('path').attr('d', path);
            
            pointsGroup.selectAll('.location-point')
                .each(function(d) {
                    const coords = projection(d.coords);
                    const point = d3.select(this);
                    
                    if (coords) {
                        const rotationLambda = projection.rotate()[0];
                        const rotationPhi = projection.rotate()[1];
                        const distance = d3.geoDistance([-rotationLambda, -rotationPhi], d.coords);
                        const isVisible = distance < Math.PI / 2;
                        
                        point.attr('transform', `translate(${coords[0]},${coords[1]})`)
                             .style('display', isVisible ? 'block' : 'none')
                             .style('opacity', isVisible ? 1 - (distance / (Math.PI / 2)) * 0.2 : 0);
                    } else {
                        point.style('display', 'none');
                    }
                });
        }
        
        // Animation système
        function startAnimation() {
            d3.timer(elapsed => {
                if (autoRotate) {
                    const rotate = projection.rotate();
                    projection.rotate([rotate[0] + 0.1, rotate[1], rotate[2]]);
                    updateAll();
                }
            });
        }
        
        // Contrôle utilisateur avec zoom
        const drag = d3.drag()
            .on('start', () => { autoRotate = false; })
            .on('drag', event => {
                const rotation = projection.rotate();
                const k = sensitivity * (scale * currentZoom) / 2;
                
                rotation[0] += event.dx / k * 180;
                rotation[1] -= event.dy / k * 180;
                rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                
                projection.rotate(rotation);
                updateAll();
            })
            .on('end', () => {
                setTimeout(() => { autoRotate = true; }, 2000);
            });
        
        // Application des contrôles
        svg.call(drag).call(zoom);
        
        // AJOUT: Écouteur de mouvement de souris pour les informations biome
        let lastBiomeUpdate = 0;
        svg.on('mousemove', function(event) {
            const now = Date.now();
            if (now - lastBiomeUpdate < 150) return;
            lastBiomeUpdate = now;
            
            const mousePos = d3.pointer(event);
            const detection = detectBiomeFromCursor(mousePos);
            
            if (detection) {
                updateBiomeInfoPanel(detection.biome, detection.lat, detection.lon);
            }
        });

        svg.on('mouseleave', function() {
            document.getElementById('biome-info-panel').classList.add('hidden');
        });
        // FIN AJOUT
        
        // Désactiver le zoom sur double-clic pour éviter les conflits
        svg.on('dblclick.zoom', null);
        
        // Fonctions interface système
        
        // Aperçu données terminal
        function showPreview(event, d) {
            autoRotate = false;
            
            const preview = document.getElementById('hover-preview');
            const title = preview.querySelector('.hover-title');
            const image = preview.querySelector('.hover-image');
            
            // Position système aléatoire
            const titleX = Math.random() * (window.innerWidth - 250);
            const titleY = Math.random() * (window.innerHeight - 50);
            
            const imageX = Math.random() * (window.innerWidth - 180);
            const imageY = Math.random() * (window.innerHeight - 120);
            
            title.textContent = d.name;
            title.style.left = titleX + 'px';
            title.style.top = titleY + 'px';
            
            image.src = d.preview.image;
            image.style.left = imageX + 'px';
            image.style.top = imageY + 'px';
            
            preview.classList.add('visible');
        }
        
        // Masquage aperçu
        function hidePreview() {
            autoRotate = true;
            document.getElementById('hover-preview').classList.remove('visible');
        }
        
        // Affichage mosaïque système avec placement sans collision
        function showDetail(event, d) {
            event.stopPropagation();
            
            const overlay = document.getElementById('detail-overlay');
            const content = overlay.querySelector('.detail-content');
            
            // Images système supplémentaires
            const systemImages = [
                'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400',
                'https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=400',
                'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400',
                'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400',
                'https://images.unsplash.com/photo-1448375240586-882707db888b?w=400',
                'https://images.unsplash.com/photo-1469474968028-56623f02e42e?w=400',
                'https://images.unsplash.com/photo-1506197603052-3cc9c3a201bd?w=400',
                'https://images.unsplash.com/photo-1444927714506-8492d94b5ba0?w=400'
            ];
            
            const sizes = ['tiny', 'small', 'medium', 'large'];
            const sizeMap = {
                tiny: { width: 160, height: 200 },
                small: { width: 200, height: 250 },
                medium: { width: 250, height: 300 },
                large: { width: 300, height: 350 }
            };
            
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight * 2.5;
            const spacing = 30; // Espacement minimum entre les blocs
            
            // Array pour stocker les positions occupées
            let occupiedPositions = [];
            
            // Fonction de détection de collision
            function isColliding(x, y, width, height, positions) {
                for (let pos of positions) {
                    if (x < pos.x + pos.width + spacing &&
                        x + width + spacing > pos.x &&
                        y < pos.y + pos.height + spacing &&
                        y + height + spacing > pos.y) {
                        return true;
                    }
                }
                return false;
            }
            
            // Fonction pour trouver une position libre
            function findFreePosition(width, height, maxAttempts = 100) {
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const x = Math.random() * (containerWidth - width - spacing);
                    const y = Math.random() * (containerHeight - height - spacing) + 80;
                    
                    if (!isColliding(x, y, width, height, occupiedPositions)) {
                        return { x, y };
                    }
                }
                
                // Si aucune position libre trouvée, placer en grille
                const cols = Math.floor(containerWidth / (width + spacing));
                const currentIndex = occupiedPositions.length;
                const row = Math.floor(currentIndex / cols);
                const col = currentIndex % cols;
                
                return {
                    x: col * (width + spacing) + spacing,
                    y: row * (height + spacing) + 100
                };
            }
            
            let html = '<div class="mosaic-container">';
            
            // Blocs données originaux
            d.detail.sections.forEach((section, index) => {
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                const dimensions = sizeMap[size];
                const position = findFreePosition(dimensions.width, dimensions.height);
                
                // Enregistrer la position occupée
                occupiedPositions.push({
                    x: position.x,
                    y: position.y,
                    width: dimensions.width,
                    height: dimensions.height
                });
                
                html += `
                    <div class="mosaic-block ${size}" style="left: ${position.x}px; top: ${position.y}px;">
                        <h3>${section.subtitle}</h3>
                        <img src="${section.image}" alt="${section.subtitle}">
                        <p>${section.text}</p>
                    </div>
                `;
            });
            
            // Fragments système supplémentaires
            for (let i = 0; i < 12; i++) {
                const size = sizes[Math.floor(Math.random() * sizes.length)];
                const dimensions = sizeMap[size];
                const position = findFreePosition(dimensions.width, dimensions.height);
                const imageIndex = Math.floor(Math.random() * systemImages.length);
                
                // Enregistrer la position occupée
                occupiedPositions.push({
                    x: position.x,
                    y: position.y,
                    width: dimensions.width,
                    height: dimensions.height
                });
                
                html += `
                    <div class="mosaic-block ${size}" style="left: ${position.x}px; top: ${position.y}px;">
                        <h3>DATA_FRAGMENT_${String(i + 1).padStart(3, '0')}</h3>
                        <img src="${systemImages[imageIndex]}" alt="Fragment ${i + 1}">
                        <p>SYSTEM_LOG: ECOSYSTEM_${d.name.split('_')[0]}.DAT | STATUS: ANALYZING | THREAT_LEVEL: VARIABLE | MONITORING: CONTINUOUS</p>
                    </div>
                `;
            }
            
            html += '</div>';
            
            content.innerHTML = html;
            overlay.classList.add('visible');
            
            autoRotate = true;
        }
        
        // Fermeture système
        function closeDetailOverlay() {
            document.getElementById('detail-overlay').classList.remove('visible');
        }
        
        // Raccourci système
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDetailOverlay();
            }
        });
        
        // Redimensionnement système avec zoom
        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const s = Math.min(w, h) / 2.8;
            
            svg.attr('width', w).attr('height', h);
            projection.scale(s * currentZoom).translate([w / 2, h / 2]);
            updateAll();
        });
    </script>
</body>
</html>